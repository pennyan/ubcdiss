\chapter{The Reflection-based Integration Architecture}
\label{ch:arch}

The architecture of \smtlink{} is composed of a chain of verified
clause-processors and one trusted clause-processor.
In ACL2, a clause-processor is a program that takes a clause as input and
produces a set of output clauses.
A verified clause-processor ensures that the conjunction of output clauses imply
the input clause through the proof of a correctness lemma.
The verified clause-processors are sound by construction. The last
clause-processor is a trusted clause-processor that transliterates from the ACL2
language to the Z3 language. A trusted clause-processor is not verified. We
formulate the soundness argument in Chapter~\ref{ch:soundness}.

Furthermore, \smtlink{} uses reflection-based verified clause-processors to
achieve soundness and performance together.
Here, reflection refers to \smtlink{}'s ability of syntactically manipulating
an ACL2 term while preserving its logical meaning.
The reflection-based verified clause-processors use \texttt{:meta-extract} which
supports meta-level reasoning using valid terms extracted from the ACL2 world.
This capability allows \smtlink{} to perform sound reasoning on its own, without
producing additional goals.

In this chapter, we first introduce the high-level architecture of \smtlink{}.
Specifically, it uses computed-hints for automating the relay of goals between
different clause-processors.
The architecture can be easily reconfigured to take extra transformation steps.
We then discuss each of the verified clause-processors. The functionality and
the algorithms in the clause-processors.
We also discuss the design of a typed-term that allows us to preserve the type
inference results and pass them between clause-processors soundly.
These type inference information enables the transformation in other
clause-processors, for example, in the replacement clause-processor.

\section{The Extensible Architecture}
The Smtlink architecture enables an extensible and reconfigurable architecture.
In particular, we define a ``hint-wrapper''\cite{hint-wrapper} function that
always returns \texttt{nil} called \texttt{SMT::hint-please}.
Clauses in ACL2 are represented as lists of disjuncts, and our hint-wrapper can
be added as a disjunct to any clause without changing the validity of the
clause.
\texttt{SMT::hint-please} takes one input argument -- the list of hints.

As is shown in~\ref{fig:arch}, the computed-hint called
\texttt{SMT::SMT-computed-hint} searches for a disjunct of the form
\texttt{(SMT::hint-please ...)} in each goal generated by ACL2.
When it finds such an instance, the \texttt{SMT::SMT-computed-hint}
will return a \texttt{computed-hint-replacement} of the form:
\begin{lstlisting}[style=codestyle]
  `(:computed-hint-replacement
    ((SMT::SMT-computed-hint clause))
    (:clause-processor (SMT::some-verified-cp clause ,combined-hint)))
\end{lstlisting}
This applies the next verified clause-processor called
\texttt{SMT::some-verified-cp} to the current subgoal and installs the
computed-hint \texttt{SMT::SMT-computed-hint} on subsequent subgoals again.
The \texttt{SMT::some-verified-cp} clause-processor is one step in a sequence of
verified clause processors.
\smtlink{} uses a configuration table called \texttt{*smt-architecture*} to
specify the sequence of clause processors, as shown in Figure~\ref{fig:arch}.
Each clause processor consults this table to determine its successor.

\begin{figure}\begin{center}
  \resizebox{1.0\textwidth}{!}{\input{figs/arch.pdf_t}}
  \caption{The Smtlink Architecture}\label{fig:arch}
\end{center}\end{figure}

For example, after Smtlink finishes processing user hints, it then consults the
configuration table for the name of the next clause-processor, which is ``CP1''
for adding user hypotheses.
A \texttt{SMT::hint-please} term is added to the list of clauses, and it informs
the computed-hint what clause-processor hint to generate for the next step.
Note that this architecture is configured by an alist table that can be easily
extended and reconfigured.

\section{The Verified Clause Processors}
Let $G$ denote the goal to be proven, and $h$ denote the Smtlink hint provided
by the user, Smtlink uses several verified clause processors to transform the
goal into a form that can be readily translated into Z3.
The first is a clause processor that processes the flat form of user hint into a
structured data structure.
It produces an error if the hint is syntactically wrong. The goal is unchanged.

The next five clause processors transforms the goal itself. Firstly, it adds
hypotheses provided by the user by instantiating existing theorem statements.
Then, non built-in functions are expanded out according to user hints.
After that, hypotheses in the goal are reordered so that type predicates come
first. 
This is to prepare the goal for type inference.
Then a type inference clause processor is used to produce type information for
subgoals.
The last is a clause processor that does term replacement.
These clause processors uses \texttt{:meta-extract} for achieving reflection.
This means that transformations can be done soundly without having to produce
additional goals.

Two other clause processors are used for preparing for the trusted clause
processors. One clause processor generates hints that are used in the trusted
clause processor for the transliteration. Then another one is used for
extracting type predicates out of the goal.

In this chapter, we will discuss each of the verified clause processors in
detail. We demonstrate an example and walk through the transformations on it.
We will discuss the algorithms that runs in each of the clause processors.

\subsection{A Nonlinear Inequality Example}


\subsection{Process User Hints}

\subsection{Add User Hypotheses}

\subsection{Expand Functions}

\subsection{Reorder Hypotheses}

\subsection{Infer Types}

\subsection{Replace Terms}

\subsection{Generate Trusted Clause-processor Hints}

\subsection{Extract Types}

\section{The Trusted Clause Processor and the SMT Solver}

\section{Conclusion}