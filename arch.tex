\chapter{The Reflection-based Integration Architecture}
\label{ch:arch}

The architecture of \smtlink{} is composed of a chain of verified
clause-processors and one trusted clause-processor.
In ACL2, a clause-processor is a program that takes a clause as input and
produces a set of output clauses.
A verified clause-processor ensures that the conjunction of output clauses imply
the input clause through the proof of a correctness lemma.
The verified clause-processors are sound by construction. The last
clause-processor is a trusted clause-processor that transliterates from the ACL2
language to the Z3 language. A trusted clause-processor is not verified. We
formulate the soundness argument in Chapter~\ref{ch:soundness}.

Furthermore, \smtlink{} uses reflection-based verified clause-processors to
achieve soundness and performance together.
Here, reflection refers to \smtlink{}'s ability of syntactically manipulating
an ACL2 term while preserving its logical meaning.
The reflection-based verified clause-processors use \texttt{:meta-extract} which
supports meta-level reasoning using valid terms extracted from the ACL2 world.
This capability allows \smtlink{} to perform sound reasoning on its own, without
producing additional goals.

In this chapter, we first introduce the high-level architecture of \smtlink{}.
Specifically, it uses computed-hints for automating the relay of goals between
different clause-processors.
The architecture can be easily reconfigured to take extra transformation steps.
Secondly, we discuss the design of a typed-term that allows us to preserve the
type inference results, and pass them between clause-processors soundly.
These type inference information enables the transformation in other
clause-processors, for example, in the replacement clause-processor.
Thirdly, we will discuss for each of the verified clause-processors -- its
functionality and the algorithms in the clause-processor.

% There doesn't exist a direct correspondence of the alist type in Z3. One of the
% idea is to use \texttt{ArraySort} to represent alists. However, there are
% several difficulties.
% First, ACL2 alists can be empty but Z3 arrays are infinite. We solve this
% problem by using constant arrays initialized with \texttt{nil} constants to
% represent empty alists.
% Second, the destructor function \texttt{assoc-equal} doesn't correspond directly
% to Z3's \texttt{Select} function. More specifically, \texttt{assoc-equal}
% produces a cons-pair, while \texttt{Select} produces a value.
% To solve these problems, for each alist type, we provide a corresponding array
% definition in ACL2.
% As is described in Chapter~\ref{ch:arch}, the replacement clause-processor
% replaces uses of alist recognizers, empty alists, \texttt{acons},
% \texttt{assoc-equal} and \texttt{cdr} with their corresponding array functions.

\section{The Extensible Architecture}
\begin{figure}\begin{center}
  \resizebox{1.0\textwidth}{!}{\input{figs/arch.pdf_t}}
  \caption{The Smtlink Architecture}\label{fig:arch}
\end{center}\end{figure}

\Yan{Needs expansion and rewriting}
\smtlink{} uses the hint wrapper approach from
\texttt{books/hints/hint-wrapper.lisp}.
In particular, we define a ``hint-wrapper'' called \texttt{SMT::hint-please} in
package \texttt{:smtlink} that always returns \texttt{nil}.
Clauses in ACL2 are represented as lists of disjuncts, and our hint-wrapper
can be added as a disjunct to any clause without changing the validity of the
clause.
\texttt{SMT::hint-please} takes one input argument -- the list of hints.

The computed-hint called \texttt{SMT::SMT-computed-hint} searches for a
disjunct of the form \\
\texttt{(SMT::hint-please ...)} in each goal generated by ACL2.
When it finds such an instance, the \texttt{SMT::SMT-computed-hint}
will return a \texttt{computed-hint-replacement} of the form:
\begin{lstlisting}[style=codestyle]
  `(:computed-hint-replacement
    ((SMT::SMT-computed-hint clause))
    (:clause-processor (SMT::some-verified-cp clause ,combined-hint)))
\end{lstlisting}
This applies the next verified clause-processor called
\texttt{SMT::some-verified-cp} to the current subgoal and installs the
computed-hint \texttt{SMT::SMT-computed-hint} on subsequent subgoals again.
The \texttt{SMT::some-verified-cp} clause-processor is one step in a sequence of
verified clause processors.
\smtlink{} uses a configuration table called \texttt{*smt-architecture*} to
specify the sequence of clause processors, as shown in Figure~\ref{fig:arch}.
Each clause processor consults this table to determine its successor.
By updating this table, \smtlink{} is easily reconfigured.

\section{Typed Term}
1. Why we need a typed term.

2. What is a typed term composed of.

3. How is it used.

4. Why is it good.

\section{The Verified Clause Processors}
Discuss each of the verified clause-processors:

1. why is it necessary to have it in smtlink

2. how is it designed

3. why it can be proved sound

Some questions: Should we use examples in these chapters? how to properly use
examples?

Am I missing anything that should be stressed?

\subsection{Process User Hints}

\subsection{Add User Hypotheses}

\subsection{Expand Functions}

\subsection{Reorder Hypotheses}

\subsection{Infer Types}

\subsection{Replace Terms}

\subsection{Generate Trusted Clause-processor Hints}

\subsection{Extract Types}
