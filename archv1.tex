\chapter{The Reflection-based Integration Architecture}
\label{ch:arch}

The architecture of \smtlink{} is composed of a chain of verified
clause-processors and one trusted clause-processor.
In ACL2, a clause-processor is a program that takes a clause as input and
produces a set of output clauses.
A verified clause-processor ensures that the conjunction of output clauses imply
the input clause through the proof of a correctness lemma.
The verified clause-processors are sound by construction. The last
clause-processor is a trusted clause-processor that transliterates from the ACL2
language to the Z3 language. A trusted clause-processor is not machine verified.
We formulate the soundness argument in Chapter~\ref{ch:soundness}.

\smtlink{} uses reflection-based verified clause-processors to achieve soundness
and performance together.
Here, reflection refers to \smtlink{}'s ability of syntactically manipulating
an ACL2 term while preserving its logical meaning.
The reflection-based verified clause-processors use \texttt{:meta-extract} which
supports meta-level reasoning using valid terms extracted from the ACL2 world.
This capability allows \smtlink{} to perform sound reasoning on its own, without
producing additional goals.

In this chapter, we first introduce the high-level architecture of \smtlink{}.
Specifically, it uses computed-hints for automating the relay of goals between
different clause-processors.
The architecture can be easily reconfigured to take extra transformation steps.
We then discuss each of the verified clause-processors. The functionality and
the algorithms in the clause-processors.
We also discuss the design of a typed-term that allows us to preserve the type
inference results and pass them between clause-processors soundly.
These type inference information enables the transformation in other
clause-processors, for example, in the replacement clause-processor.

\section{The Extensible Architecture}
The Smtlink architecture enables an extensible and reconfigurable architecture.
We define a ``hint-wrapper''\cite{hint-wrapper} function that always returns
\texttt{nil} called \texttt{SMT::hint-please}.
Clauses in ACL2 are represented as lists of disjunctions, and our hint-wrapper
can be added as a disjunct to any clause without changing the validity of the 
clause.
\texttt{SMT::hint-please} takes one input argument -- the list of hints.

Figure~\ref{fig:arch} shows the architecture of Smtlink.
The computed-hint called \\
\texttt{SMT::SMT-computed-hint} searches for a disjunct of the form
\texttt{(SMT::hint-please ...)} in each goal generated by ACL2.
When it finds such an instance, the \texttt{SMT::SMT-computed-hint}
will return a \texttt{computed-hint-replacement} of the form:
\begin{lstlisting}[style=codestyle]
  `(:computed-hint-replacement
    ((SMT::SMT-computed-hint clause))
    (:clause-processor (SMT::some-verified-cp clause ,combined-hint)))
\end{lstlisting}
This applies the next verified clause-processor called
\texttt{SMT::some-verified-cp} to the current subgoal and installs the
computed-hint \texttt{SMT::SMT-computed-hint} on subsequent subgoals again.
The \texttt{SMT::some-verified-cp} clause-processor is one step in a sequence of
verified clause processors.
\smtlink{} uses a configuration table called \texttt{*smt-architecture*} to
specify the sequence of clause processors, as shown in Figure~\ref{fig:arch}.
Each clause processor consults this table to determine its successor.

\begin{figure}\begin{center}
  \resizebox{1.0\textwidth}{!}{\input{figs/arch.pdf_t}}
  \caption{The Smtlink Architecture}\label{fig:arch}
\end{center}\end{figure}

For example, after Smtlink finishes processing user hints, it then consults the
configuration table for the next clause-processor, which is ``CP1'' for adding
user hypotheses.
A \texttt{SMT::hint-please} term is added to the list of clauses, and it informs
the computed-hint what clause-processor hint to generate for the next step.
The computed-hint will then be able to install the next step for adding user
hypotheses. Likewise, at the end of ``CP1'', a \texttt{SMT::hint-please} term is
added to the list of clauses, and it again informs the computed-hint what
clause-processor hint to generate next.
Note that this architecture is configured by an alist table that can be easily
extended and reconfigured.

\section{The Verified Clause Processors}
Let $G$ denote the goal to be proven, and $h$ denote the Smtlink hint provided
by the user, Smtlink uses several verified clause processors to transform the
goal into a form that can be readily translated into Z3. The first is a clause
processor that processes the unstructured list form of user hint into a
structured data structure. It produces an error if the hint is syntactically
wrong. The goal itself is unchanged.

The next five clause processors do transformations over the goal.
The first of them adds hypotheses provided by the user by instantiating existing
theorem statements.
The second clause-processor expands non built-in functions according to user
hints.
After that, another clause-processor reorders hypotheses in the goal so that
type predicates come first in the disjunct of clauses. The algorithm of
type-inference depends on this assumption.
Two type inference clause processors are used to produce type information for
subterms.
The last is a clause processor that does term replacement. Term replacement are
useful for dispatching types for polymorphic functions in ACL2, but is not
limited to such use.
These clause processors uses \texttt{:meta-extract} for achieving reflection.
This means that transformations can be done soundly without having to produce
additional goals.

Two other clause processors are used for preparing information needed for the
trusted clause processors.
One clause processor generates hints that are used in the trusted clause
processor for the transliteration. Another one is used for extracting type
predicates out of the goal.

In this chapter, we will discuss each of the verified clause processors in
detail. We demonstrate an example and walk through the transformations on it.
We will discuss the algorithms that runs in each of the clause processors.

\subsection{An Example}
Consider theorem~\ref{prog:poly} as an example:
\begin{program}[H]
  \caption{A nonlinear inequality problem}
  \label{prog:poly}
  \lstinputlisting[language=Lisp]{progs/poly.lisp}
\end{program}

In this theorem, we want to prove that \ldots. \Yan{Example in development}
When providing \texttt{:smtlink [smt-hint]} as the hint, the user is informing
ACL2 to use Smtlink, instead of the default ACL2 waterfall for discharging the
goal.

\subsubsection{The Smtlink Hint}
\begin{program}[h]
  \caption{The Smtlink Hint}
  \label{prog:hint}
  \lstinputlisting[language=Lisp]{progs/hint-top.lisp}
\end{program}

The Smtlink hint follows a structure as shown in~\ref{prog:hint}.
There are two modes of Smtlink. The \texttt{:smtlink} hint is the standard
Smtlink that uses the built-in interface to the SMT solver. The
\texttt{:smtlink-custom} could be used when an intrepid user want to extend the
default SMT interface provided by Smtlink.
The \texttt{:functions} option provides information for return type and
expansion level of user-defined functions.
The \texttt{:hypotheses} provides names of theorem statements that can be used
as known facts for helping the SMT solver to discharge the goal.
The \texttt{:acl2types} option provides type information for type inference in
ACL2.
The \texttt{:datatypes} option provides type information for translating types
in the SMT solver.
The \texttt{:replaces} option provides names of theorem statements for term
replacement.
The \texttt{:int-to-ratp} option specifies that the user wants to translates all
integers as reals in the \acs{SMT} solver. This is convenient because Z3 doesn't
support mixing of the non-linear solver and integer theories. 
The \texttt{:smt-fname} option specifies the name of the produced \acs{SMT}
file. If unspecified, Smtlink automatically generates a name that avoids naming
collision.
The \texttt{:rm-file} specifies whether one wants to remove the produced file.
By default the file is kept.
The \texttt{:smt-dir} specifies where to write the produced file. By default, it
is stored at \texttt{/tmp/py\_file}.

\paragraph{functions: }
\begin{program}[h]
  \caption{The \texttt{:function} smtlink hint}
  \label{prog:funchint}
  \lstinputlisting[language=Lisp]{progs/hint-function.lisp}
\end{program}

The \texttt{:function} hint follows a structure as shown
in~\ref{prog:funchint}. \texttt{[function-name]} is the name of the function.
The option \texttt{:return} describes a list of \texttt{[theorem
  specification]}s that can be used for inferring return types of the given
function.
The option \texttt{:depth} describes how many times a function will be expanded.
The default value for \texttt{:depth} is $0$. Non-basic function that are left
in the term after expansion are treated as uninterpreted functions. For
soundness, Smtlink returns a subgoal stating the return type of the
uninterpreted function.
The option \texttt{:uninterpreted-hints} provides hints to help discharging this
subgoal.
The options \texttt{:translation}, \texttt{:return-type} and
\texttt{:fn-to-const} are used in~\ref{prog:datatypehint} for the
transliteration in the trusted clause-processor.

A \texttt{[theorem specification]} follows the structured in~\ref{prog:thmspec},
which essentially requires a theorem name and a list of formals of the given
function of interest.

\begin{program}[h]
  \caption{The theorem specification hint}
  \label{prog:thmspec}
  \lstinputlisting[language=Lisp]{progs/hint-thm-spec.lisp}
\end{program}

\paragraph{hypotheses: }
\begin{program}[h]
  \caption{The \texttt{:hypotheses} smtlink hint}
  \label{prog:hypohint}
  \lstinputlisting[language=Lisp]{progs/hint-hypotheses.lisp}
\end{program}

The \texttt{:hypotheses} hint follows a structure as shown
in~\ref{prog:hypohint}. It follows the standard ACL2 \texttt{:use} hint where
one specifies an established theorem to use and the bindings for instantiating
the theorem.

\paragraph{acl2types: }

\begin{program}[h]
  \caption{The \texttt{:acl2types} smtlink hint}
  \label{prog:acl2typehint}
  \lstinputlisting[language=Lisp]{progs/hint-acl2types.lisp}
\end{program}

The \texttt{:acl2types} hint as shown in~\ref{prog:acl2typehint} specifies types
that are used in ACL2 type inference clause processors. The \texttt{:subtype}
option specifies types that are subtypes of the given type of interest. An
established theorem must be provided to justify the subtyping relationship using
the \texttt{:thm} option. Likewise, the \texttt{:supertype} option is for types
that are supertypes of the given type of interest. The \texttt{:thm} option
follows the structure as shown in~\ref{prog:thmspec}.

\paragraph{datatypes: }

\begin{program}[h]
  \caption{The \texttt{:datatypes} smtlink hint}
  \label{prog:datatypehint}
  \lstinputlisting[language=Lisp]{progs/hint-datatypes.lisp}
\end{program}

The \texttt{:datatypes} option describes datatypes that will be defined in the
\acs{SMT} solver. There are three type of \texttt{:datatypes}. The first option
is \texttt{:sumtypes} that specifies sorts that are defined using the Z3
\texttt{Datatype} feature. These essentially define sums of products. The second
option is \texttt{:arrays} that specifies array sorts that are defined using the
Z3 \texttt{ArraySort} feature. The third option is \texttt{:abstracts} which
defines abstract sorts using \texttt{DeclareSort}.

\begin{program}[H]
  \caption{The \texttt{:sumtypes} datatypes hint}
  \label{prog:sumtypehint}
  \lstinputlisting[language=Lisp]{progs/hint-sum.lisp}
\end{program}

For \texttt{:sumtypes}, if the algebraic datatype is tagged, then one can
provide a kind function through the option \texttt{:kind}. Otherwise,
\texttt{:kind} will be \texttt{nil}, indicating an untagged sum. The option
\texttt{:recognizer} describes the recognizer function for this algebraic
datatype. The function description follows~\ref{prog:funchint} where
\texttt{:translation} specifies which string should the function be translated
into, \texttt{:return-type} specifies the return type of the function and
\texttt{:fn-to-const} describes whether this function should be translated into
a constant in Z3. This is used for the translation of \texttt{nil} functions
into nil constants in Z3. The \texttt{:equal} function specifies an equality
function for this algebraic datatype. The \texttt{:sums} option specifies all
products in the sum. Each product contains a \texttt{:constructor} and a list of
\texttt{:destructors}. Finally, the \texttt{:property-hints} specifies hints for
proving the returned properties for this algebraic datatype.

\begin{program}[h]
  \caption{The \texttt{:arrays} datatypes hint}
  \label{prog:arrayhint}
  \lstinputlisting[language=Lisp]{progs/hint-array.lisp}
\end{program}

As is with \texttt{:sumtypes}, for \texttt{:arrays}, one provides a recognizer
function through the \texttt{:recognizer} option. The \texttt{:key-type} and
\texttt{:val-type} options provide type for the key and the value respectively.
The \texttt{:init} option specifies the initialization function for an empty
array. Its \texttt{:fn} option specifies the function and its \texttt{:val}
option specifies the default value function name. The option \texttt{:select}
and \texttt{:store} specifies the \texttt{Select} and \texttt{Store} functions
for this array sort. The \texttt{:equal} option specifies the equality function
for this array sort and \texttt{:equal-witness} is the witness function for the
equality. The \texttt{:property-hints} specifies hints for proving the returned
properties for this array sort.

\begin{program}[h]
  \caption{The \texttt{:abstracts} datatypes hint}
  \label{prog:abstracthint}
  \lstinputlisting[language=Lisp]{progs/hint-abstract.lisp}
\end{program}

For \texttt{:abstracts}, one merely provides a recognizer through
\texttt{:recognizer} and an equality function through \texttt{:equal}.
The \texttt{:property-hints} specifies hints for proving the returned
properties for this abstract sort.

\paragraph{replaces: }

\begin{program}[h]
  \caption{The \texttt{:replaces} smtlink hint}
  \label{prog:replacehint}
  \lstinputlisting[language=Lisp]{progs/hint-replaces.lisp}
\end{program}

The \texttt{:replaces} option describes theorem statements that can be useful
for term replacement. The term replacement option takes a list of theorem
specifications which has its structure described at~\ref{prog:thmspec}.

In the rest of this Chapter, we will discuss each of the verified
clause-processors.

\subsection{Process User Hints}
The first verified clause processor processes user provided hints to Smtlink. It
syntactically check the hint and processes user hints in flat list form into a
structured data structure. It then generates a disjunct in the many disjunctions
of the goal using \texttt{SMT::hint-please}. This disjunct informs the computed
hint which next clause-processor to use and with which hint.

Take~\ref{prog:poly} as an example, assume the initial goal is $G$ and initial
hint is $h$, in this case, $G$ is the goal

\begin{lstlisting}[style=codestyle,language=LISP]
(this is a placeholder)
\end{lstlisting}

\noindent and $h$ is the hint \texttt{nil}. In this case, no user hint is
provides, therefore the syntactical check passes and the verified clause
processor produces the same goal $G$ and the structured hint $h'$:

\begin{lstlisting}[style=codestyle,language=LISP]
(this is a placeholder)
\end{lstlisting}

The clause processor consults the \texttt{SMT-architecture} table for the next
clause processor to install. It then produces below disjunctions of clauses as
output.

\begin{lstlisting}[style=codestyle,language=LISP]
  (this is a placeholder)
\end{lstlisting}

Note that since the goal itself is untouched, and that the
\texttt{SMT::hint-please} disjunct always returns true, ACL2 can easily
discharge the soundness lemma for this verified clause processor.

\subsection{Add User Hypotheses}

To use an \acs{SMT} solver effectively, one needs to know how to avoid
overwhelming it with too many facts that push it over an exponential complexity
cliff. The user can guide this process by adding hypotheses for the \acs{SMT}
solver. The user hypotheses are established facts from the ACL2 logical world --
theorems that are already proven. The user provides the name of the theorem
statement and the bindings to the formals with the Smtlink hint.

\begin{algorithm}[!ht]
  \DontPrintSemicolon
  
  \KwInput{Clause $G$, Smtlink hint $h'$}
  \KwOutput{New Clause $G_{hypo}$, Smtlink hint $h'$}

  \SetKwFunction{null}{null}
  \SetKwFunction{car}{car}
  \SetKwFunction{mycdr}{cdr}
  \SetKwFunction{mycons}{cons}
  \SetKwFunction{not}{not}
  \SetKwFunction{mtextract}{meta-extract}
  \SetKwFunction{simpletv}{simple-term-vars}

  \SetKwFunction{addhypo}{add-user-hypotheses}
  \SetKwFunction{shhypo}{smtlink-hint->hypotheses}
  \SetKwFunction{hpthm}{hypothesis->thm}
  \SetKwFunction{hpsubst}{hypothesis->subst}
  \SetKwFunction{exlambda}{expand-lambda}
  \SetKwFunction{createsubst}{create-subst}
  
  \;
  $HypoList \longleftarrow $\shhypo{$h'$}\;
  $G_{hypo} \longleftarrow G$\;
  \addhypo{$G_{hypo}, HypoList, state$}\;
  \;
  \Fn{\addhypo{$G_{hypo}, HypoList, state$}}{
    \If{\null{$HypoList$}}{
      \Return $G_{hypo}$
    }\Else{
      $Hypo$, $HypoList$ $\longleftarrow$ \car{$HypoList$}, \mycdr{$HypoList$}\;
      
      $HypoThmName \longleftarrow$ \hpthm{$Hypo$}\;
      $HypoThm \longleftarrow$ \mtextract{$HypoThmName, w$}\;
      
      $HypoThmExpanded \longleftarrow$ \exlambda{$HypoThm$}\;

      $Vars \longleftarrow$ \simpletv{$HypoThmExpanded$}\;
      $UserSubst \longleftarrow$ \hpsubst{$Hypo$}\;
      $Subst \longleftarrow$ \createsubst{$UserSubst$, $Vars$}\;
      $HypoThmSubsted \longleftarrow [Subst]HypoThmExpanded$\;
      
      $G_{hypo} \longleftarrow$ \mycons{\not{$HypoThmSubsted$}, $G_{hypo}$}\;
      \Return \addhypo{$G_{hypo}, HypoList, state$}
    }
  }

  \caption{Add User Hypotheses}\label{alg:userhypo}
\end{algorithm}

Given the input clause $G$ and the Smtlink hint $h'$,
Algorithm~\ref{alg:userhypo} shows the algorithm for the adding user hypotheses
clause processor. First, the list of hypotheses $HypoList$ is extracted from the
Smtlink hint data structure. For each of the hypothesis in the list, first, we
use \texttt{meta-extract} to get the theorem statement using the name of the
theorem $HypoThmName$. The theorem is expanded out to eliminate lambdas. Then we
create a binding for substitution $Subst$ and substitute it into the expanded
term $HypoThmSubsted$. Finally, the substituted theorem statement
$HypoThmSubsted$ is negated and added into the list of disjunctions of the goal.

The \texttt{meta-extract} mechanism allows Smtlink to extract facts from the
logical world of ACL2. These are proven facts therefore must be valid. We then
add the fact as one of the hypotheses of the goal. We can reason that this
transformation over the syntax of the original goal is a sound transformation
and doesn't change the logical meaning of the original goal. This rule-guided
transformation of the goal is a main theme of our reflection-based verified
clause-processors. 

\subsection{Expand Functions}

\begin{table}[h!]
  \begin{center}
    \caption{Built-in Functions}
    \label{tb:builtin}
    \begin{tabular}{|l|c|r|}
      \textbf{built-in function} & \textbf{SMT interface}\\
      \hline
      \texttt{binary-+} & \texttt{\_SMT\_.plus}\\
      \texttt{binary-*} & \texttt{\_SMT\_.times}\\
      \texttt{unary-/} & \texttt{\_SMT\_.reciprocal}\\
      \texttt{unary--} & \texttt{\_SMT\_.negate}\\
      \texttt{equal} & \texttt{\_SMT\_.equal}\\
      \texttt{<} & \texttt{\_SMT\_.lt}\\
      \texttt{if} & \texttt{\_SMT\_.ifx}\\
      \texttt{not} & \texttt{\_SMT\_.notx}\\
    \end{tabular}
  \end{center}
\end{table}

The next clause processor expands functions.
We define a set of built-in functions~\ref{tb:builtin}. User-defined functions
are expanded out. Recursive functions are expanded to a provided depth. The
result of expansion is composed of only built-in functions and user-defined
functions that are not fully expanded.
The Z3 interface class provides SMT equivalents for built-in functions.
Occurrences of user-defined functions are treated as uninterpreted functions.

Given the input clause $G_{hypo}$ and the Smtlink hint $h'$,
Algorithm~\ref{alg:expand1} shows the algorithm for function expansion. Suppose
the inputs to the function expansion clause processor are $G_{hypo}$ and $h'$.
The algorithm first prepare the goal by disjoining the list of disjunctions and
construct the information needed for function expansion from the smtlink hint.
Three accumulators are introduced. $FnLvls$ remembers how many levels are left
to expand functions. $TermVarAlist$ remembers new variables generated for
subterms. $Avoid$ remembers free variables that appears in the goal and have
been generated. Function \texttt{expand-term} and \texttt{expand-term-list} are
the mutual recursion describing the algorithm for function expansion.

If $Term$ exists in $TermVarAlist$, then return the stored variable. Otherwise
if the $Term$ is a function call that requires generating a fresh var, we first
recursively call \texttt{expand-term-list} on the actuals. If the function $Fn$
should not be expanded (\texttt{dont-expand} returns \texttt{t}), return the
term with updated actuals. Otherwise, generate new variables for the actuals and
construct the updated term. Then, expand the function by substituting the
actuals into the body of the function definition. We update the \texttt{FnLvls}
after the expansion and recursively call \texttt{expand-term} over the resulting
expanded term. Finally, generate a new variable for the resulting term.
The \texttt{expand-term-list} function expands a list of terms by recursively
calling \texttt{expand-term} over a list of terms. Note that the termination
proof of  this algorithm relies on an additional variable $Clock$ which is not
shown in the pseudo-code. The function \texttt{function-substitution} uses
\texttt{meta-extract} to extract a function definition rule from the ACL2 world.
The function definition rule gives us a fact that states an equality between the
function call and function body. The soundness of the function expansion
algorithm originates from these function definition rules.

\begin{algorithm}[!ht]
  \DontPrintSemicolon
  
  \KwInput{Clause $G_{hypo}$, Smtlink hint $h'$}
  \KwOutput{New Clause $G_{expand}$, Smtlink hint $h'$}

  \SetKwFunction{mycdr}{cdr}
  \SetKwFunction{consp}{consp}
  \SetKwFunction{disjoin}{disjoin}
  \SetKwFunction{consopt}{construct-expand-options}
  \SetKwFunction{expand}{expand-term}
  \SetKwFunction{genvar}{generate-freshvar}
  \SetKwFunction{expandlist}{expand-term-list}
  \SetKwFunction{dontexpand}{dont-expand}
  \SetKwFunction{newvar}{new-var-for-term}
  \SetKwFunction{newvarlist}{new-vars-for-term-list}
  \SetKwFunction{funcsubst}{function-substitution}
  \SetKwFunction{updatelvl}{update-fn-lvls}
  
  \;
  $G_{expand} \longleftarrow$ \disjoin{$G_{hypo}$}\;
  $Options \longleftarrow$ \consopt{$h'$}\;
  $FnLvls \longleftarrow nil$\;
  $TermVarAlist \longleftarrow nil$\;
  $Avoid \longleftarrow$ \simpletv{$G_{hypo}$}\;
  \expand{{$G_{expand}, Options, FnLvls, TermVarAlist, Avoid, state$}}\;
  \;
  \Fn{\expand{$Term, Options, FnLvls, TermVarAlist, Avoid, state$}}{
    \If{$Term$ \in $TermVarAlist$}{
      \Return $TermVarAlist[Term]$, $TermVarAlist$, $Avoid$
    }\ElseIf{\genvar{$Term$}}{
      $Fn \longleftarrow$ \car{$Term$}\;
      $Actuals \longleftarrow$ \mycdr{$Term$}\;
      $Actuals, TermVarAlist, Avoid \longleftarrow$
      \expandlist{$Actuals, Options, FnLvls, TermVarAlist, Avoid, state$}\;
      \If{\dontexpand{$Fn, Options, FnLvls$}}{
        $Term \longleftarrow$ \mycons{$Fn, Actuals$}\;
        \Return $Term$, $TermVarAlist$, $Avoid$
      }
      \Else{
        $ActualVars, TermVarAlist, Avoid \longleftarrow$
        \newvarlist{$Actuals, TermVarAlist, Avoid$}\;
        $VarTerm \longleftarrow$ \mycons{$Fn, ActualVars$}\;
        $SubstedBody \longleftarrow$ \funcsubst{$VarTerm, state$}\;
        $FnLvls \longleftarrow$ \updatelvl{$Fn, Options, Fnlvls$}\;
        $Term, TermVarAlist, Avoid \longleftarrow$
        \expand{$SubstedBody, Options, FnLvls, TermVarAlist, Avoid, state$}\;
        \Return \newvar{$Term, TermVarAlist, Avoid$}
      }
    }
    \Else{
      \Return $Term$, $TermVarAlist$, $Avoid$
    }
  }
  \caption{Expand Functions (Part1 of 3)}\label{alg:expand1}
\end{algorithm}

\begin{algorithm}
  \DontPrintSemicolon
  
  \SetKwFunction{acons}{acons}
  \SetKwFunction{exoptfunc}{expand-options->functions}
  \SetKwFunction{funcdepth}{smt-function->depth}
  \SetKwFunction{flambdap}{flambdap}
  
  \setcounter{AlgoLine}{27}
  \Fn{\expandlist{$TermList, Options, FnLvls, TermVarAlist, Avoid, state$}}{
    \If{\consp{$TermList$}}{
      $TermHd \longleftarrow$ \car{$TermList$}\;
      $TermTl \longleftarrow$ \mycdr{$TermList$}\;
      $TermHd, TermVarAlist, Avoid \longleftarrow$
      \expand{$TermHd, Options, FnLvls, TermVarAlist, Avoid, state$}\;
      $TermTl, TermVarAlist, Avoid \longleftarrow$
      \expandlist{$TermTl, Options, FnLvls, TermVarAlist, Avoid, state$}\;
      $TermList \longleftarrow$ \mycons{$TermHd, TermTl$}\;
      \Return $TermList, TermVarAlist, Avoid$
    }
    \Else{
      \Return $nil, TermVarAlist, Avoid$
    }
  }
  \;
  \Fn{\dontexpand{$Fn, Options, FnLvls$}}{
    $Functions \longleftarrow$ \exoptfunc{$Options$}\;
    \If{$Fn$ \in $FnLvls$}{
      \Return $FnLvls[Fn] \leq 0$
    }
    \ElseIf{$Fn$ \in $Functions$}
    {
      $FnOpt \longleftarrow Functions[Fn]$\;
      \Return \funcdepth{$FnOpt$} $\leq 0$
    }
    \Else{
      \Return $nil$
    }
  }
  \;
  \Fn{\updatelvl{$Fn, Options, Fnlvls$}}{
    $Functions \longleftarrow$ \exoptfunc{$Options$}\;
    \If{$Fn$ \in $FnLvls$}{
      $FnLvls \longleftarrow$ \acons{$Fn, FnLvls[Fn]-1, FnLvls$}
    }
    \ElseIf{$Fn$ \in $Functions$}{
      $FnOpt \longleftarrow Functions[Fn]$\;
      $FnLvls[Fn] \longleftarrow $
        \acons{$Fn$, \funcdepth{$FnOpt$}$-1$, $FnLvls$}
    }
    \Else{
      $FnLvls[Fn] \longleftarrow 0$
    }
    \Return $FnLvls$
  }

  \caption{Expand Functions (Part 2 of 3)}\label{alg:expand2}
\end{algorithm}

\begin{algorithm}
  \DontPrintSemicolon

  \SetKwFunction{pattern}{pattern-match}
  \SetKwFunction{sowu}{simple-one-way-unify}

  \setcounter{AlgoLine}{58}
  \Fn{\funcsubst{$Term, state$}}{
    $Fn \longleftarrow$ \car{$Term$}
    \If{\flambdap{$Fn$}}{
      \Return \exlambda{$Term$}
    }
    \Else{
      $Formula \longleftarrow$ \mtextract{$Fn, state$}\;
      $Lhs, Rhs \longleftarrow$ \pattern{$Formula$, ('equal\ Lhs\ Rhs)}\;
      $Subst \longleftarrow$ \sowu{$Lhs, Term, nil$}\;
      \Return $[Subst]Rhs$
    }
  }
  \;
  \Fn{\newvar{$Term, TermVarAlist, Avoid$}}{
    \If{\genvar{$Term$}}{
      \Return $Term, TermVarAlist, Avoid$
    }\Else{
      $Var \longleftarrow$ \newvar{$Avoid$}\;
      $TermVarAlist \longleftarrow$ \acons{$Term, Var, TermVarAlist$}\;
      $Avoid \longleftarrow$ \mycons{$Var, Avoid$}\;
      \Return $Var, TermVarAlist, Avoid$
    }
  }

  \Fn{\newvarlist{$TermList, TermVarAlist, Avoid$}}{
    \If{\consp{$TermList$}}{
      $TermHd \longleftarrow$ \car{$TermList$}\;
      $TermTl \longleftarrow$ \mycdr{$TermList$}\;
      $VarHd, TermVarAlist, Avoid \longleftarrow$
      \newvar{$TermHd, TermVarAlist, Avoid$}\;
      $VarTl, TermVarAlist, Avoid \longleftarrow$
      \newvarlist{$TermTl, TermVarAlist, Avoid$}\;
      \Return \mycons($VarHd, VarTl$), $TermVarAlist$, $Avoid$
    }\Else{
      \Return $TermList, TermVarAlist, Avoid$
    }
  }
  \caption{Expand Functions (Part 3 of 3)}\label{alg:expand3}
\end{algorithm}

In terms of time complexity, suppose the number of arguments for a function is
$w_i$ and the depth of a function definition tree is $h_i$. For a recursive
function, the number of levels of expansion $l_i$ should be taken into
consideration, resulting in a total depth of $h_i\times l_i$. Treating the final
expansion result as a large tree, its depth will be $\max(h_i\times l_i)$ and
its width should be $\max(w_i)$. This means the number of recursive calls to
\texttt{expand-term} should be bounded by $O(\max(w_i)^{\max(h_i\times l_i)})$.
For each such \texttt{expand-term} call, the complexity is bounded by the
maximum of the size of $FnLvls$, $TermVarAlist$, $Avoid$ and function body
sizes. Let's call it $\delta$. Then the total time complexity is
$O(\max(w_i)^{\max(h_i\times l_i)}\times\delta)$.

\subsection{Reorder Hypotheses}

The type inference algorithm replies on the type hypotheses of free variables in
the goal coming before all other disjunctions. Therefore, we introduce the next
clause processor for reordering hypotheses. More specifically, it reorders the
disjunctions so that the typing hypotheses come first.

\begin{algorithm}
  \DontPrintSemicolon

  \SetKwFunction{reorder}{reorder-hypotheses}
  \SetKwFunction{extract}{extractor}
  \SetKwFunction{filterth}{filter-type-hypo}
  \SetKwFunction{makevt}{make-var-to-terms}
  \SetKwFunction{maketv}{make-term-to-vars}
  \SetKwFunction{orderhypo}{order-hypo-lst}
  \SetKwFunction{addhypo}{add-hypotheses}
  \SetKwFunction{findresolved}{find-resolved-var}
  \SetKwFunction{update}{update}
  \SetKwFunction{remove}{remove}
  
  \Fn{\reorder{$Term, Types$}}{
    $HypoList, RestTerm \longleftarrow$ \extract{$Term, Types$}\;
    $RootHypo, RestHypo \longleftarrow$ \filterth{$HypoList, Types$}\;
    $VarTermAlist \longleftarrow$ \makevt{$RestHypo$}\;
    $TermVarAlist \longleftarrow$ \maketv{$RestHypo$}\;
    $OrderedHypo \longleftarrow$ \orderhypo{$RootHypo$, $VarTermAlist$,
      $TermVarAlist$, $RestHypo$, $Types$}\;
    \Return \addhypo{$OrderedHypo, RestTerm$}
  }

  \Fn{\orderhypo{$WorkList, VarTermAlist, TermVarAlist, OtherHypos, Types$}}{
    \If{\consp{$WorkList$}}{
      $WorkHd \longleftarrow$ \car{$WorkList$}\;
      $WorkTl \longleftarrow$ \mycdr{$WorkList$}\;
      $ResolvedVar \longleftarrow$ \findresolved{$WorkHd$}\;
      \If{$ResolvedVar$ \in $VarTermAlist$}{
        $TermVarAlist, WorkList \longleftarrow$
        \update{$VarTermAlist[ResolvedVar], TermVarAlist, WorkTl,
          ResolvedVar$}\;
        $WorkTl \longleftarrow$ \orderhypo{$WorkList, VarTermAlist, TermVarAlist,
          OtherHypos, Types$}\;
        \Return \mycons{$WorkHd, WorkTl$}
      }\Else{
        $WorkTl \longleftarrow$ \orderhypo{$WorkTl, VarTermAlist, TermVarAlist,
          OtherHypos, Types$}\;
        \Return \mycons{$WorkHd, WorkTl$}
      }
    }\Else{
      \Return $nil$
    }
  }
  \caption{Reorder Hypotheses (Part 1 of 2)}\label{alg:reorder1}
\end{algorithm}

\begin{algorithm}
  \DontPrintSemicolon

  \setcounter{AlgoLine}{21}
  \Fn{\update{$TermList, TermVarAlist, WorkList, ResolvedVar$}}{
    \If{\consp{$TermList$}}{
      $TermHd \longleftarrow$ \car{$TermList$}\;
      $TermTl \longleftarrow$ \mycdr{$TermList$}\;
      \If{$TermHd$ \in $TermVarAlist$}{
        $Vars \longleftarrow TermVarAlist[TermHd]$\;
        $Vars \longleftarrow$ \remove{$ResolvedVar, Vars$}\;
        \If{\consp{$Vars$}}{
          $TermVarAlist \longleftarrow$ \acons{$TermHd, Vars, TermVarAlist$}\;
          \Return \update{$TermTl, TermVarAlist, WorkList, ResolvedVar$}
        }\Else{
          $TermVarAlist \longleftarrow$ \acons{$TermHd, nil, TermVarAlist$}\;
          $WorkList \longleftarrow$ \mycons{$TermHd, WorkList$}\;
          \Return \update{$TermTl, TermVarAlist, WorkList, ResolvedVar$}
        }
      }\Else{
        \Return \update{$TermTl, TermVarAlist, WorkList, ResolvedVar$}
      }
    }\Else{
      \Return $TermVarAlist, WorkList$
    }
    \caption{Reorder Hypotheses (Part 2 of 2)}\label{alg:reorder2}
}\end{algorithm}

Algorithm~\ref{alg:reorder1} and~\ref{alg:reorder2} shows the algorithm for
reordering hypotheses. First, the hypotheses list of interest are extracted from
the goal. Then \texttt{filter-type-hypo} extracts hypotheses that are type
predicates from this hypotheses list. The reordering algorithm is a topological
sort algorithm. We define the set of type predicates as the initial work list.
Then we generate an alist that maps from a variable to the list of hypothesis
containing that variable, named as $VarTermAlist$, and another alist that maps
from a term to all variables that appear in the term, named as $TermVarAlist$.

Given the current work list, the function \texttt{order-hypo-lst} shows how the
tables are updated. For each term in the work list, get the variable that is
resolved from the term. Get the list of terms that depend on this variable by
consulting the table $VarTermAlist$. For each term, update the $TermVarAlist$
table by removing the variable from the list of variables that appears in the
term. If any such list becomes empty, we know all variables of this hypothesis
have been resolved, and we can add it onto the work list.

Suppose the size of the term is $S$, there are $m$ hypotheses of interest and
each of them have at most $n$ variables to resolve. We know $m\times n < S$.
The size of $TermVarAlist$ is then $O(m)$ and the size of $VarTermAlist$ is
$O(m\times n)$. The size of the work list at any given time is bounded by
$O(m)$. The \texttt{update} function has a time complexity of $O(m\times(m+n))$.
Therefore the total run time is $O(m\times(n+m\times(m+n))) < O(S^3)$.
Note that if all the alists are fast alists (that is they are hash tables), then
the amortized time complexity becomes $O(m\times m\times n) < O(S^2)$.

\subsection{Infer Types}

\subsubsection{\texttt{typed-term}}

\subsubsection{The Bottom-up Pass}

\begin{algorithm}
  \caption{The Bottom-up Type Inference}\label{alg:bottomup}
\end{algorithm}

\subsubsection{The Top-Down Pass}

\begin{algorithm}
  \caption{The Top-down Type Inference}\label{alg:topdown}
\end{algorithm}

\subsection{Replace Terms}

\begin{algorithm}
  \caption{Replace Terms}\label{alg:replace}
\end{algorithm}

\subsection{Generate Trusted Clause-processor Hints}

\subsection{Extract Types}

\section{The Trusted Clause Processor and the SMT Solver}

\section{Conclusion}
